# Banco de Dados: Uma Aplicação CRUD

#### 01/09/2025 {.unnumbered}

#### Professor Miguél Suares {.unnumbered}

## O que é uma Aplicação CRUD?

Hoje vamos desenvolver um cadastro web simples e entender o que é o acronimo C.R.U.D.

## Conceito de CRUD

**CRUD** é um acrônimo para quatro operações fundamentais que um sistema realiza sobre dados em um banco de dados:

![](images/2025-09-01/01-CRUD.jpg)

Essas quatro operações compõem a base da maioria das **aplicações web** que manipulam dados persistidos em um **SGBD** (Sistema Gerenciador de Banco de Dados).

------------------------------------------------------------------------

## O padrão de Design de Sistemas MVC (Model View Controller)

Uma aplicação Cliente-Servidor (modelo 2 camadas) geralmente segue o **padrão MVC** — **Model, View, Controller**:

![](images/2025-09-01/03-MVC.jpg)

## Construindo uma aplicação CRUD para interfacear com a tabela "Pessoa"

Considere o Diagrama Entidade-Relacionamento abaixo:

```{plantuml aula-05-Exemplo-01-continuação, plantuml.path="images"}
@startchen
title Diagrama ER — Entidade Pessoa (Peter Chen)
left to right direction

entity PESSOAS {
  cpf <<key>>
  nome
  endereco
  data_nascimento
  foto
}

@endchen

```

Vamos Converte-lo para o Modelo Físico-Relacional em linguagem SQL:

### Representação gráfica no modelo Físico-Relacional

Vamos agora representa-lo em linguagem SQL:

![](images/2025-09-01/02-TabelaPessoas.jpg)

## Criação de uma aplicação CRUD

Vamos criar um **microsas** (micro Software As A Service) , ou seja, um site para inserir informações dentro da tabela acima.

![](images/2025-09-01/04-Aplicacao.jpg)

| Informações de Projeto | Tecnologias utilizadas no projeto CRUD |
|----|----|
| Servidor de banco de dados SGBD | MySQL 8 |
| Usuário de Banco de Dados | **pessoas_user** |
| De onde pode ser acessado | Apenas Máquina Local (localhost) |
| Esquema de Banco de Dados | **pessoasdb** |
| Servidor de Aplicação | Python 3 |
| Cliente da Aplicação | HTML + Javascript |
| Tecnologia de API | RestuFul |
| **Biblioteca de Javascript** para criar API **RestFul** | Método **Fetch** (Biblioteca Padrão do JavaScript para API RestFul) |
| Formato de Dados entre Servidor de Aplicação e Cliente de Aplicação | **JSON** |

: Criando um Esquema de Banco de Dados - CRUD tabela Pessoas

#### Criação de um usuário para Interagir com o Esquema de Banco de Dados

![](images/2025-09-01/05-Usuario.jpg)

``` sql

-- CRIAR USUÁRIO LOCAL E CONCEDER PERMISSÕES
-- Troque 'MinhaSenhaForte' por uma senha segura


CREATE USER IF NOT EXISTS 'pessoas_user'@'localhost' IDENTIFIED BY 'MinhaSenhaForte';

GRANT ALL PRIVILEGES ON pessoasdb.* TO 'pessoas_user'@'localhost';

FLUSH PRIVILEGES;
```

#### Criação do Esquema de Banco de Dados no SGBD MySQL

Agora vamos criar um esquema de Banco de Dados para abrigar nossa futura tabela:

![](images/2025-09-01/06-Esquema.jpg)

``` sql
-- 1) CRIAR BANCO (ajuste o nome se quiser)

CREATE DATABASE IF NOT EXISTS pessoasdb
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_0900_ai_ci;

USE pessoasdb;
```

#### Criação da Tabela "pessoas"

![](images/2025-09-01/07-Tabela_Pessoas.jpg)

``` sql

-- 3) TABELA 'pessoas' COMPATÍVEL COM O MODELO SQLAlchemy
--    - cpf: chave primária (String(14))
--    - nome, endereco, foto: TEXT
--    - data_nascimento: DATE

CREATE TABLE IF NOT EXISTS pessoas 
(
  cpf             VARCHAR(14)  NOT NULL,
  nome            TEXT         NOT NULL,
  endereco        TEXT         NOT NULL,
  data_nascimento DATE         NOT NULL,
  foto            TEXT         NULL,
  PRIMARY KEY (cpf)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;


-- 4) (OPCIONAL) ÍNDICES PARA BUSCA
-- Seu endpoint usa LIKE/ILIKE em nome e cpf; cpf já é PK.
-- Para acelerar buscas por nome com LIKE, crie um índice por prefixo.
-- OBS: índices em TEXT precisam de comprimento; 128 costuma ser um bom compromisso.

CREATE INDEX idx_pessoas_nome_prefix ON pessoas (nome(128));
```

#### Uma aplicação Cliente Servidor no formato MVC (Model View Controller)

```{plantuml Aplicacao-MVC-CRUD-Pessoas-01, plantuml.path="images"}
@startuml
title Aplicação CRUD (Cliente + Servidor) — Componentes UML com padrão MVC

skinparam backgroundColor #FFFFFF
skinparam componentStyle rectangle
skinparam rectangle {
  RoundCorner 12
  BorderColor #333
}
skinparam database {
  BorderColor #333
  BackgroundColor #F9F9F9
}
left to right direction

' ==========================
' CLIENTE (MVC no Navegador)
' ==========================
package "Cliente Web (Browser)" <<Client>> {
  [View\nHTML + CSS] <<View>> as C_VIEW
  [Controller\nJS (handlers + UI)] <<Controller>> as C_CTRL
  [Model\nPessoaDTO] <<Model>> as C_MODEL
  [API Service\nfetch()] <<Service>> as C_API

  C_VIEW -down-> C_CTRL : eventos do usuário (click, submit)
  C_CTRL --> C_MODEL : cria/atualiza objetos
  C_CTRL --> C_API : invoca REST (fetch)
  C_API --> C_MODEL : (de)serializa JSON
}

' Interface REST exposta pelo servidor
interface "REST API\n(JSON/HTTP)" as I_REST

C_API -[#1F78B4]-> I_REST : HTTP/1.1\nGET/POST/PUT/DELETE\nContent-Type: application/json

' ==========================
' SERVIDOR (MVC no Backend)
' ==========================
package "Servidor de Aplicação (Python 3 / Flask)" <<Server>> {
  [View\n(na prática, sem templates)] <<View>> as S_VIEW
  [Controller\nFlask Routes /pessoas] <<Controller>> as S_CTRL
  [Service\nValidação + Regra de Negócio] <<Service>> as S_SVC
  [Repository\nSQLAlchemy Session] <<Repository>> as S_REPO
  [Model\nPessoa (ORM)] <<Model>> as S_MODEL

  S_CTRL --> S_SVC : delega operações CRUD
  S_SVC --> S_REPO : transações, queries
  S_REPO --> S_MODEL : mapeamento ORM
}

I_REST -[#1F78B4]-> S_CTRL : JSON request/response\nCORS habilitado

' ==========================
' BANCO DE DADOS
' ==========================
database "MySQL 8" as DB {
  component "Schema: pessoasdb\nTabela: pessoas(cpf PK, nome, endereco, data_nascimento, foto)" as TBL
}

S_REPO -[#33A02C]-> DB : SQL (TCP 3306)\nuser=pessoas_user\nschema=pessoasdb
DB -down-> TBL

' ==========================
' NOTAS E CONSTRAINTS
' ==========================
note bottom of C_API
  Camada de integração REST (fetch):
  • GET  /pessoas[?q=]
  • GET  /pessoas/{cpf}
  • POST /pessoas
  • PUT  /pessoas/{cpf}
  • DELETE /pessoas/{cpf}
end note

note right of S_SVC
  Regras de negócio / validação:
  • Campos obrigatórios
  • Datas ISO (YYYY-MM-DD)
  • Conflitos (CPF duplicado)
  • Erros padronizados (422/404/409)
end note

note right of DB
  Acesso restrito a localhost.
  Usuário: pessoas_user
  Collation: utf8mb4_0900_ai_ci
end note

legend right
  <<View>>      Camada de apresentação
  <<Controller>>Orquestra fluxo e ações
  <<Model>>     Dados/DTO/ORM
  <<Service>>   Regras de negócio/integração
  <<Repository>>Persistência (ORM/SQL)
end legend

@enduml

```

#### Criação do Servidor de Aplicação em Linguagem Python

Vejamos a representação gráfica de nosso servidor utilizando o diagrama de classes da linguagem UML

```{plantuml Servidor-CRUD-Pessoas-01, plantuml.path="images"}

@startuml
title Diagrama de Classes — Servidor Flask + SQLAlchemy (MySQL)

skinparam backgroundColor #FFFFFF
skinparam class {
  BackgroundColor #FDFDFD
  BorderColor #333
  RoundCorner 10
}
skinparam package {
  BackgroundColor #FFFFFF
  BorderColor #555
}
left to right direction

package "API (Flask)" {
  class App <<FlaskApp>> {
    +run(debug: bool, port: int)
  }

  class PessoasController <<Controller>> {
    +listar() : Response
    +inserir() : Response
    +alterar(cpf: str) : Response
    +remover(cpf: str) : Response
    +buscar(cpf: str) : Response
  }

  class Helpers <<Helper>> {
    +to_dict(p: Pessoa) : dict
    +parse_date_iso(value: str | date) : date
  }
}

package "Persistência (SQLAlchemy)" {
  class Engine <<SQLAlchemy>> {
    +url : str
    +pool_pre_ping : bool
  }

  class SessionLocal <<SQLAlchemy>> {
    +__call__() : Session
  }

  class Session <<SQLAlchemy>>

  abstract class Base <<SQLAlchemy>>

  class Pessoa <<ORMModel>> {
    +__tablename__ = "pessoas"
    --
    +cpf : String(14)      <<PK>>
    +nome : Text
    +endereco : Text
    +data_nascimento : Date
    +foto : Text
  }
}

' ------------------ Relações ------------------
Pessoa --|> Base
PessoasController ..> SessionLocal : usa
PessoasController ..> Pessoa : CRUD
Helpers ..> Pessoa
Helpers ..> date
App ..> PessoasController : registra rotas /pessoas
Engine o-- SessionLocal
App ..> Engine

note right of Engine
  MySQL 8 (localhost)
  URL:
  mysql+pymysql://
  pessoas_user:******@localhost:3306/pessoasdb
end note

@enduml

```

Para utilizar o MySQL como servidor, devemos instalar os drivers de MySQL para a biblioteca SQLAlchemy do Python através da ferramenta de linha de comando PIP do python

``` cmd
pip install flask flask-cors sqlalchemy "pymysql>=1.1"
# (ou use mysqlclient: pip install mysqlclient e troque o driver para mysql+mysqlclient)
```

Agora vamos escrever o script python que criará o servidor de aplicação para interfacear nosso Cliente no Navegador e nossa tabela pessoas dentro do SGBD MySQL:

``` python
from flask import Flask, request, jsonify
from flask_cors import CORS
from sqlalchemy import create_engine, Column, String, Date, Text
from sqlalchemy.orm import sessionmaker, declarative_base
from datetime import date

# ------------------------------
# Flask + CORS
# ------------------------------
app = Flask(__name__)
CORS(app)  # em produção, restrinja as origens

# ------------------------------
# Banco de Dados MySQL (localhost)
# ------------------------------
# Parâmetros do projeto:
#   SGBD: MySQL 8
#   Host: localhost
#   Usuário: pessoas_user
#   DB/Schema: pessoasdb
#   Tabela: pessoas
DATABASE_URL = "mysql+pymysql://pessoas_user:MinhaSenhaForte@localhost:3306/pessoasdb"

engine = create_engine(
    DATABASE_URL,
    pool_pre_ping=True,        # evita "MySQL server has gone away"
    future=True
)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False, future=True)
Base = declarative_base()

# ------------------------------
# Modelo Pessoa
# ------------------------------
class Pessoa(Base):
    __tablename__ = "pessoas"
    cpf = Column(String(14), primary_key=True)
    nome = Column(Text, nullable=False)
    endereco = Column(Text, nullable=False)
    data_nascimento = Column(Date, nullable=False)
    foto = Column(Text)  # Base64 ou URL

# Cria a tabela se não existir (deve existir conforme seu script SQL)
Base.metadata.create_all(engine)

# ------------------------------
# Helpers
# ------------------------------
def to_dict(p: Pessoa):
    return {
        "cpf": p.cpf,
        "nome": p.nome,
        "endereco": p.endereco,
        "data_nascimento": p.data_nascimento.isoformat(),
        "foto": p.foto
    }

def parse_date_iso(value):
    if isinstance(value, date):
        return value
    return date.fromisoformat(value)  # espera "YYYY-MM-DD"

# ------------------------------
# CRUD
# ------------------------------

# Listar todas as pessoas ou pesquisar por termo (?q=)
@app.route('/pessoas', methods=['GET'])
def listar():
    termo = (request.args.get('q') or '').strip()
    with SessionLocal() as session:
        query = session.query(Pessoa)
        if termo:
            like = f"%{termo}%"
            # MySQL é case-insensitive com collation *_ci; ilike é traduzido para LIKE
            query = query.filter((Pessoa.nome.ilike(like)) | (Pessoa.cpf.ilike(like)))
        pessoas = query.order_by(Pessoa.nome.asc()).all()
        return jsonify([to_dict(p) for p in pessoas])

# Inserir nova pessoa
@app.route('/pessoas', methods=['POST'])
def inserir():
    dados = request.get_json(force=True)
    required = ['cpf', 'nome', 'endereco', 'data_nascimento']
    faltantes = [k for k in required if not dados.get(k)]
    if faltantes:
        return jsonify({"error": "Campos obrigatórios faltando", "fields": faltantes}), 422

    try:
        dn = parse_date_iso(dados['data_nascimento'])
    except Exception:
        return jsonify({"error": "data_nascimento inválida. Use YYYY-MM-DD"}), 422

    with SessionLocal() as session:
        if session.query(Pessoa).filter_by(cpf=dados['cpf']).first():
            return jsonify({"error": "CPF já cadastrado"}), 409
        pessoa = Pessoa(
            cpf=dados['cpf'],
            nome=dados['nome'],
            endereco=dados['endereco'],
            data_nascimento=dn,
            foto=dados.get('foto')
        )
        session.add(pessoa)
        session.commit()
        session.refresh(pessoa)
        return jsonify(to_dict(pessoa)), 201

# Alterar pessoa (PUT)
@app.route('/pessoas/<cpf>', methods=['PUT'])
def alterar(cpf):
    dados = request.get_json(force=True)
    with SessionLocal() as session:
        pessoa = session.query(Pessoa).filter_by(cpf=cpf).first()
        if not pessoa:
            return jsonify({"error": "CPF não encontrado"}), 404

        if 'nome' in dados and dados['nome'] is not None:
            pessoa.nome = dados['nome']
        if 'endereco' in dados and dados['endereco'] is not None:
            pessoa.endereco = dados['endereco']
        if 'data_nascimento' in dados and dados['data_nascimento'] is not None:
            try:
                pessoa.data_nascimento = parse_date_iso(dados['data_nascimento'])
            except Exception:
                return jsonify({"error": "data_nascimento inválida. Use YYYY-MM-DD"}), 422
        if 'foto' in dados:
            pessoa.foto = dados['foto']

        session.commit()
        session.refresh(pessoa)
        return jsonify(to_dict(pessoa)), 200

# Remover pessoa
@app.route('/pessoas/<cpf>', methods=['DELETE'])
def remover(cpf):
    with SessionLocal() as session:
        pessoa = session.query(Pessoa).filter_by(cpf=cpf).first()
        if not pessoa:
            return jsonify({"error": "CPF não encontrado"}), 404
        session.delete(pessoa)
        session.commit()
        return '', 204

# Buscar pessoa por CPF
@app.route('/pessoas/<cpf>', methods=['GET'])
def buscar(cpf):
    with SessionLocal() as session:
        pessoa = session.query(Pessoa).filter_by(cpf=cpf).first()
        if not pessoa:
            return jsonify({"error": "CPF não encontrado"}), 404
        return jsonify(to_dict(pessoa))

# ------------------------------
# Inicia o servidor
# ------------------------------
if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

#### Criação do Cliente de Aplicação em HTML (Parte Gráfica) e Javascript (Programação Executável)

Vamos verificar como é o Diagrama de Classes do Cliente que vai conversar com o servidor que vimos anteriormente:

![](images/2025-09-01/09-cliente.jpg)

Agora vamos verificar o código-fonte.

Salve esse código em um arquivo chamado **cliente.html**, para poder abrir-lo no navegador, juntamente com o servidor rodando:

``` html
<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Cadastro de Pessoas - Flask/MySQL</title>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; max-width: 980px; margin: 24px auto; }
  label { display: block; margin-top: 10px; }
  button { margin-top: 10px; margin-right: 6px; padding: 8px 12px; }
  table { border-collapse: collapse; width:100%; margin-top:20px; }
  th, td { border:1px solid #ddd; padding:8px; text-align:left; }
  img.thumb { width:60px; height:60px; object-fit:cover; border-radius:4px; }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
</style>
</head>
<body>
<h1>Cadastro de Pessoas (Flask/MySQL)</h1>

<form id="formPessoa">
  <label>CPF (chave primária): <input id="cpf" required></label>
  <label>Nome: <input id="nome" required></label>
  <label>Endereço: <input id="endereco" required></label>
  <label>Data Nasc.: <input type="date" id="data_nascimento" required></label>
  <label>Foto: <input type="file" id="foto" accept="image/*"></label>

  <div class="row">
    <button type="button" id="btnInserir" onclick="inserir()">Inserir</button>
    <button type="button" id="btnAlterar" onclick="alterar()">Alterar</button>
    <button type="button" id="btnRemover" onclick="remover()">Remover</button>
  </div>
</form>

<h2>Pesquisar</h2>
<div class="row">
  <input id="pesquisa" placeholder="Digite nome ou CPF" style="flex:1">
  <button type="button" id="btnPesquisar" onclick="pesquisar()">Pesquisar</button>
  <button type="button" onclick="listar()">Listar tudo</button>
</div>

<table>
  <thead>
    <tr>
      <th>CPF</th><th>Foto</th><th>Nome</th>
      <th>Endereço</th><th>Nascimento</th>
    </tr>
  </thead>
  <tbody id="tabela"></tbody>
</table>

<script>
const API = 'http://localhost:5000/pessoas';

/* ---------- Helpers ---------- */
function setBusy(busy) {
  for (const id of ['btnInserir','btnAlterar','btnRemover','btnPesquisar']) {
    const el = document.getElementById(id);
    if (el) el.disabled = busy;
  }
}

function validaCampos() {
  const campos = ['cpf','nome','endereco','data_nascimento'];
  for (const id of campos) {
    const valor = document.getElementById(id).value.trim();
    if (!valor) {
      alert(`O campo "${id}" não pode ficar em branco.`);
      return false;
    }
  }
  return true;
}

function getFotoBase64() {
  const file = document.getElementById('foto').files[0];
  if(!file) return Promise.resolve('');
  return new Promise((resolve,reject)=>{
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

function coletaDados(base64Foto){
  return {
    cpf: document.getElementById('cpf').value.trim(),
    nome: document.getElementById('nome').value.trim(),
    endereco: document.getElementById('endereco').value.trim(),
    data_nascimento: document.getElementById('data_nascimento').value, // YYYY-MM-DD
    foto: base64Foto || ''
  };
}

async function readJsonSafe(res) {
  const ct = res.headers.get('content-type') || '';
  if (ct.includes('application/json')) {
    try { return await res.json(); } catch { return null; }
  }
  return null;
}

/* ---------- CRUD ---------- */
async function inserir() {
  if(!validaCampos()) return;
  setBusy(true);
  try {
    const base64 = await getFotoBase64();
    const pessoa = coletaDados(base64);

    const res = await fetch(API, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(pessoa)
    });
    const data = await readJsonSafe(res);
    if(res.ok) {
      alert('Inserido com sucesso!');
      listar();
      document.getElementById('formPessoa').reset();
    } else {
      alert('Erro: ' + (data?.error || res.statusText));
    }
  } catch (e) {
    alert('Falha ao inserir: ' + e.message);
  } finally {
    setBusy(false);
  }
}

async function alterar() {
  if(!validaCampos()) return;
  const cpf = document.getElementById('cpf').value.trim();
  setBusy(true);
  try {
    const base64 = await getFotoBase64();
    const novosDados = coletaDados();
    if (base64) novosDados.foto = base64;

    const res = await fetch(`${API}/${encodeURIComponent(cpf)}`, {
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(novosDados)
    });
    const data = await readJsonSafe(res);
    if(res.ok) {
      alert('Alterado com sucesso!');
      listar();
    } else {
      alert('Erro: ' + (data?.error || res.statusText));
    }
  } catch (e) {
    alert('Falha ao alterar: ' + e.message);
  } finally {
    setBusy(false);
  }
}

async function remover() {
  const cpf = document.getElementById('cpf').value.trim();
  if(!cpf) return alert('Informe o CPF para remover.');
  if(!confirm('Confirma a exclusão?')) return;

  setBusy(true);
  try {
    const res = await fetch(`${API}/${encodeURIComponent(cpf)}`, {method:'DELETE'});
    // 204 => sem corpo; não tente parsear JSON aqui
    if(res.status === 204) {
      alert('Removido com sucesso!');
      listar();
      return;
    }
    const data = await readJsonSafe(res);
    if(res.ok) {
      alert('Removido com sucesso!');
      listar();
    } else {
      alert('Erro: ' + (data?.error || res.statusText));
    }
  } catch (e) {
    alert('Falha ao remover: ' + e.message);
  } finally {
    setBusy(false);
  }
}

async function pesquisar() {
  const termo = document.getElementById('pesquisa').value.trim();
  setBusy(true);
  try {
    const url = termo ? `${API}?q=${encodeURIComponent(termo)}` : API;
    const res = await fetch(url);
    const data = await readJsonSafe(res);
    if(!res.ok) return alert('Falha na pesquisa: ' + (data?.error || res.statusText));
    preencheTabela(Array.isArray(data) ? data : (data?.items ?? []));
  } catch (e) {
    alert('Falha na pesquisa: ' + e.message);
  } finally {
    setBusy(false);
  }
}

async function listar() {
  setBusy(true);
  try {
    const res = await fetch(API);
    const data = await readJsonSafe(res);
    if(!res.ok) return alert('Falha ao listar: ' + (data?.error || res.statusText));
    preencheTabela(Array.isArray(data) ? data : (data?.items ?? []));
  } catch (e) {
    alert('Falha ao listar: ' + e.message);
  } finally {
    setBusy(false);
  }
}

/* ---------- UI ---------- */
function preencheTabela(lista){
  const tbody = document.getElementById('tabela');
  tbody.innerHTML = '';
  (lista || []).forEach(p=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${p.cpf}</td>
      <td>${p.foto ? `<img class="thumb" src="${p.foto}" alt="foto">` : ''}</td>
      <td>${p.nome}</td>
      <td>${p.endereco}</td>
      <td>${p.data_nascimento}</td>`;
    tr.onclick = () => {
      document.getElementById('cpf').value = p.cpf;
      document.getElementById('nome').value = p.nome;
      document.getElementById('endereco').value = p.endereco;
      document.getElementById('data_nascimento').value = p.data_nascimento;
    };
    tbody.appendChild(tr);
  });
}

listar();
</script>
</body>
</html>
```

### Resultado final:

#### Servidor de aplicação Python "Restful" rodando

![](images/2025-09-01/10-servidor_rodando.jpg)

#### Cliente HTML + Javascript ( página ESTÁTICA ) aberta no navegador

##### Passo 1 - Preencher dados no formulário do cliente

Vamos inserir dados de exemplo no "cliente WEB" abaixo

![](images/2025-09-01/11-Cliente_Vazio.jpg)

##### Passo 2 - Pressionar o Botão INSERIR

![](images/2025-09-01/11-Cliente_Vazio-02.jpg)

OBS: Na tela do servidor, é possível verificar as operações HTTP Equivalentes ao SQL que foram executadas entre o Servidor e o Cliente

![](images/2025-09-01/10-servidor_rodando-01.jpg)

##### Passo 3 - Verificar se o "DBGRID" do cliente "espelhando" a linha da tabela "pessoas" no esquema "pessoasdb" do SQBG MySQL

![](images/2025-09-01/11-Cliente_03-Preenchido.jpg)

##### Passo 4 - Verificar na tabela pessoas a linha que o cliente preencheu através da API da aplicação cliente/servidor

![](images/2025-09-01/12-Dados_no_SGBD.jpg)

## Feito

```{r Executa_pagina_aula_05_, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
rmarkdown::render("05-2025-09-01_Aplicacao_CRUD-aula.Rmd", output_dir="docs", output_file ="temporario.html" , output_format = "html_document") ; utils::browseURL("docs/temporario.html")
```
